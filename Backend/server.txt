require("dotenv").config(); // Load environment variables
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const bodyParser = require('body-parser');
const nodemailer = require("nodemailer");
const http = require('http');  // Required for Socket.IO
const { Server } = require("socket.io");

const app = express();
const server = http.createServer(app);  // Create HTTP server
const io = new Server(server, {        // Attach Socket.IO to the server
  cors: {
    origin: "http://localhost:3001",  // Allow frontend
    methods: ["GET", "POST"],
    transports: ["websocket", "polling"], // Ensure WebSocket support
    credentials: true
  }
});
const PORT = 3000;

// Middleware
app.use(cors({
   origin: "http://localhost:3001",  // Allow requests from localhost:3001
   methods: ["GET", "POST", "PUT", "PATCH", "DELETE"],
   allowedHeaders: ["Content-Type", "Authorization"], // Add headers if needed
   credentials: true,  // Allow cookies/credentials
   }));
   
app.use(express.json());
app.use(bodyParser.json());
app.use(express.urlencoded({ extended: true }));
app.use("/uploads", express.static(path.join(__dirname, "uploads")));

// Connect to MongoDB
mongoose.connect('mongodb://localhost:27017/AnantDrishti', {
  useNewUrlParser: true,
  useUnifiedTopology: true
}).then(() => console.log('Connected to MongoDB (Local)'))
  .catch(err => console.error('Error connecting to MongoDB (Local):', err));

  // mongoose.connect('mongodb://193.203.160.6:27017/AnantDrishti', {
  //   useNewUrlParser: true,
  //   useUnifiedTopology: true
  // }).then(() => console.log('Connected to MongoDB (Remote)'))
  //   .catch(err => console.error('Error connecting to MongoDB (Local):', err));

// //User Connection of another database
//  mongoose.connect('mongodb://193.203.160.6:27017/AnantDrishti', {
//   useNewUrlParser: true,
//   useUnifiedTopology: true,
// })
//  .then(() => {
//   console.log('Connected to MongoDB (Remote)');
// }).catch(err => console.error('Error connecting to MongoDB (Remote):', err));

// :white_check_mark: Email Transporter Setup (Fixed)
const transporter = nodemailer.createTransport({
  service: "gmail", // :white_check_mark: Correct service name
  auth: {
    user: process.env.EMAIL_USER, // :white_check_mark: Your email from .env
    pass: process.env.EMAIL_PASS, // :white_check_mark: App password (Not normal password)
  },
});

// :white_check_mark: Function to Send Email (Improved)
async function sendMail(to, subject, text, html) {
  try {
    const info = await transporter.sendMail({
      from: "Anant Ki Drishti" <${process.env.EMAIL_USER}>,
      to,
      subject,
      text,
      html,
    });
    console.log(":e-mail: Email sent successfully:", info.messageId);
    return { success: true, message: "Email sent successfully" };
  } catch (error) {
    console.error(":x: Error sending email:", error);
    return { success: false, message: "Failed to send email", error: error.message };
  }
}

const profileSchema = new mongoose.Schema({
  profileImage: { type: String, default: "" },
  firstName: { type: String, required: true },
  lastName: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },  // :fire: Add this line
  phone: { type: String, required: true },
  address: {
    street: { type: String, default: "" },
    city: { type: String, default: "" },
    postalCode: { type: String, default: "" },
    state: { type: String, default: "" },
    country: { type: String, default: "" },
  },
}, { timestamps: true });

const Profile = mongoose.model('profiles', profileSchema);

// Store connected admins for notifications
let connectedAdmins = [];

io.on("connection", (socket) => {
  console.log("Admin connected for notifications:", socket.id);
  connectedAdmins.push(socket);

  socket.on("disconnect", () => {
    console.log("Admin disconnected:", socket.id);
    connectedAdmins = connectedAdmins.filter(admin => admin !== socket);
  });
});


// :white_check_mark: Signup Route with Email & Notification
app.post("/signup", async (req, res) => {
  console.log("Received signup request:", req.body);
  
  try {
    let { firstName, lastName, email, password, phone } = req.body;
    if (!firstName || !lastName || !email || !password || !phone ) {
      console.log("Signup error: Missing email or password");
      return res.status(400).json({ success: false, message: "Email and password are required" });
    }

    
    email = email.toLowerCase(); // Ensure email is stored in lowercase

    const existingUser = await Profile.findOne({ email });
    if (existingUser) {
      return res.json({ success: false, message: "User already exists" });
    }

    // :white_check_mark: Default empty address (admin can edit later in Profile.js)
    const defaultAddress = {
      street: "",
      city: "",
      postalCode: "",
      state: "",
      country: "",
    };

    const newUser = new Profile({ 
      firstName,
      lastName,
      email,
      password, // Make sure to hash the password in production
      phone,
      address: defaultAddress,  // :white_check_mark: Assign empty address by default
    });

    await newUser.save();


    // :white_check_mark: Send Welcome Email
    const emailResponse = await sendMail(
      email,
      "Welcome to Anant ki Drishti",
      "Hi, thank you for registering on Anant ki Drishti.",
      "<p>Hi,</p><p>Thank you for registering on Anant ki Drishti.</p>"
    );

    if (!emailResponse.success) {
      return res.json({ success: false, message: "User registered, but email failed" });
    }

    // :white_check_mark: Emit real-time notification to connected admins
    
    io.emit("newUser", { message: New user ${firstName} ${lastName} is registered. })
    console.log(":bell: Notification Sent:", New user ${firstName} ${lastName} registered!);

    res.json({ success: true, message: "Signup successful, email sent" });
  } catch (err) {
    console.error(":x: Signup error:", err);
    res.status(500).json({ success: false, message: "Error during signup" });
  }
});

// :white_check_mark: Login Route
app.post("/login", async (req, res) => {
  const { email, password } = req.body;

  try {
    console.log(":mag: Incoming Login Request:", req.body); 

   
    if (!email || !password) {
      console.log(":x: Missing email or password");
      return res.status(400).json({ success: false, message: "Email and password are required" });
    }

    // Find the user by email
    const user = await Profile.findOne({ email });
    if (!user) {
      console.log(":x: Login failed: User not found ->", email);
      return res.status(400).json({ success: false, message: "User not found" });
    }

    console.log(":white_check_mark: User found:", user);

    // Directly compare passwords (No Hashing)
    if (user.password !== password) {
      console.log(":x: Login failed: Invalid password for user ->", email);
      return res.status(400).json({ success: false, message: "Invalid password" });
    }

    console.log(":white_check_mark: Password Matched: Login successful!");

    // If passwords match, send the user data
    return res.json({
      success: true,
      message: "Login successful",
      admin: {
        _id: user._id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        profileImage: user.profileImage || "/default-avatar.png",
      },
    });

  } catch (err) {
    console.error("Login error:", err);
    return res.status(500).json({ 
      success: false, 
      message: "Internal server error", 
      error: err.message 
    });
  }
});


// Example route for dashboard (requires authentication)
app.get('/api/dashboard', (req, res) => {
  // In this case, we are not using JWT, but you can manually check session/cookie for authentication
  res.json({ success: true, message: 'Welcome to the dashboard!' });
});

// Get the logged-in admin's profile details
app.get("/profile", async (req, res) => {
  const { id } = req.query;
  if (!id) {
    return res.status(400).json({ message: "Admin ID is required" });
  }
  try {
    const adminProfile = await Profile.findById(id); 
    if (!adminProfile) {
      return res.status(404).json({ message: "Profile not found" });
    }
    res.json(adminProfile);
  } catch (err) {
    res.status(500).json({ message: "Error fetching profile" });
  }
});


// :white_check_mark: Ensure the directory exists for storing profile images
const profileUploadPath = "uploads/AdminProfile/";
if (!fs.existsSync(profileUploadPath)) {
  fs.mkdirSync(profileUploadPath, { recursive: true });
}

// :white_check_mark: Multer storage configuration for profile images
const profileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, profileUploadPath); // Save the images in uploads/AdminProfile/
  },
  filename: (req, file, cb) => {
    cb(null, file.originalname); // Add timestamp to filename for uniqueness
  },
});
const uploadProfile = multer({ storage: profileStorage });

// :white_check_mark: API to Update Admin Profile
app.post("/update-profile", uploadProfile.single("profileImage"), async (req, res) => {
  try {
     const { adminId, firstName, lastName, email, phone, street, city, postalCode, state, country } = req.body;
    if (!adminId) {
      return res.status(400).json({ success: false, message: "Admin ID is required" });
    }
    let updatedData = {
      firstName,
      lastName,
      email,
      phone,
      address: { street, city, postalCode, state, country },
    };
    if (req.file) {
      updatedData.profileImage = /uploads/AdminProfile/${req.file.filename};
    }
    let adminProfile = await Profile.findOne({ email }); 
    if (adminProfile) {
      adminProfile = await Profile.findOneAndUpdate({ email }, updatedData, { new: true });
    } else {
      adminProfile = new Profile(updatedData);
      await adminProfile.save();
    }
    res.json({ success: true, updatedProfile: adminProfile });
  } catch (err) {
    console.error(":x: Error updating profile:", err);
    if (err instanceof multer.MulterError) {
      return res.status(400).json({ success: false, message: "File upload error" });
    }
    res.status(500).json({ success: false, message: "Internal Server Error" });
  }
});


// User Schema & Model

const userSchema = new mongoose.Schema({
  firstName: String,
  lastName: String,
  email: String,
  password :String,
  phone: String,
  dob :{type: Date , required:true},
  address: {
    street: String,
    city: String,
    postalCode: String,
    country: String
  },
  loginSessions: [
    {
      date: String,
      time: String,
      location: String
    }
  ],
  orders: [
    {
      orderId: String,
      productName: String,
      price: Number,
      date: String,
      status: String
    }
  ]
}, { timestamps: true });


const User = mongoose.model('users', userSchema);

// User Routes
app.get("/users", async (req, res) => {
  try {
    const users = await User.find({}); // Fetch all users
    if (!users || users.length === 0) {
      return res.status(404).json({ message: "No users found" });
    }
    res.json(users);
  } catch (error) {
    console.error("Error fetching users:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
});


app.get("/users/:id", async (req, res) => {
  try {
    const userId = req.params.id;
    console.log("User ID:", userId);  // Log the received ID

    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({ message: "Invalid user ID format" });
    }

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    res.json(user);
  } catch (error) {
    console.error("Error fetching user:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
});

app.post('/users', async (req, res) => {
  try {
    const newUser = new User(req.body);
    await newUser.save();
    res.status(201).json(newUser);
  } catch (error) {
    res.status(500).json({ message: 'Failed to create user', error });
  }
});

app.put('/users/:id', async (req, res) => {
  const userId = req.params.id;
  const updatedUserData = req.body;

  console.log("Received update request for User ID:", userId);
  console.log("Updated user data:", updatedUserData); // Debugging log

  // Ensure the ID is valid
  if (!mongoose.Types.ObjectId.isValid(userId)) {
    return res.status(400).json({ message: "Invalid user ID format." });
  }

  try {
    const updatedUser = await User.findByIdAndUpdate(userId, 
      { $set: updatedUserData }, 
      { new: true, runValidators: true }
    );
    if (!updatedUser) {
      console.log("User not found in database.");
      return res.status(404).json({ message: 'User not found' });
    }
    console.log("User updated successfully:", updatedUser);
    res.status(200).json(updatedUser);
  } catch (error) {
    console.error("Error updating user:", error);
    res.status(500).json({ message: 'Failed to update user', error: error.message });
  }
});



// Address Schema
const addressSchema = new mongoose.Schema({
  name: String,
  email: String,
  phone: String,
  address: String,
  city: String,
  state: String,
  pin: String,
  country: String,
  isDefaultAddress: Boolean
});

const Address = mongoose.model('addresses', addressSchema);

// Address Routes
app.get('/addresses', async (req, res) => {
  try {
    const addresses = await Address.find();
    res.json(addresses);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});



// Product Schema & Model
const productSchema = new mongoose.Schema({
  name: String,
  description: String,
  image: String,
  price: Number,
  stock: Number,
  status: { type: String, enum: ['available', 'out of stock'], default: 'available' },
  category: String,
  discount: Number,
  size: String,
  color: String,
});
const Product = mongoose.model('products', productSchema);

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/Products/');
  },
  filename: function (req, file, cb) {
    cb(null,file.originalname);
  }
});

const upload = multer({ storage: storage });


// Create Product
app.post('/products', upload.single('image'), async (req, res) => {
  try {
    console.log(":inbox_tray: Incoming Request Body:", req.body);
    console.log(":outbox_tray: Uploaded File:", req.file);

    if (!req.body.name || !req.body.price || !req.body.category) {
      return res.status(400).json({ error: "Missing required fields" });
    }

    if (!req.file) {
      return res.status(400).json({ error: "Image upload failed" });
    }

    const imagePath = /uploads/Products/${req.file.originalname};
    const product = new Product({ ...req.body, image: imagePath });
    await product.save();

    res.status(201).json(product);
  } catch (error) {
    console.error(":x: Error adding product:", error);
    res.status(500).json({ error: "Error adding product", details: error.message });
  }
});


// Product fetch route
app.get("/products", async (req, res) => {
  try {
    const products = await Product.find({});
    res.json(products);
  } catch (error) {
    console.error("Error fetching products:", error);
    res.status(500).send("Error fetching products");
  }
});


app.get("/products/:id", async (req, res) => {
  try {
    const { id } = req.params;

    // Validate ObjectId
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: ":x: Invalid product ID format" });
    }

    const product = await Product.findById(id);
    if (!product) {
      return res.status(404).json({ message: ":x: Product not found" });
    }

    res.status(200).json(product);
  } catch (error) {
    console.error(":x: Error fetching product:", error);
    res.status(500).json({ message: ":x: Error fetching product", error });
  }
});

app.delete('/products/:id', async (req, res) => {
  try {
    const product = await Product.findByIdAndDelete(req.params.id);
    if (!product) return res.status(404).json({ message: 'Product not found' });

    res.json({ success: true, message: 'Product deleted successfully' });
  } catch (error) {
    res.status(500).json({ message: 'Error deleting product', error });
  }
});

// Update Product
app.put('/products/:id', upload.single('image'), async (req, res) => {
  try {
    const product = await Product.findById(req.params.id);
    if (!product) return res.status(404).json({ message: "Product not found" });

    let imagePath = product.image; // Keep existing image if not updated
    if (req.file) {
      imagePath = /uploads/Products/${req.file.originalname}; // :white_check_mark: Store new image in correct folder
    }

    const updatedProduct = await Product.findByIdAndUpdate(
      req.params.id,
      { ...req.body, image: imagePath },
      { new: true }
    );

    res.json(updatedProduct);
  } catch (error) {
    console.error(":x: Error updating product:", error);
    res.status(500).json({ error: "Error updating product" });
  }
});



app.put('/products/:id/status', async (req, res) => {
  try {
    console.log("Received request to update product status for ID:", req.params.id);

    const product = await Product.findById(req.params.id);
    if (!product) {
      console.log("Product not found");
      return res.status(404).json({ message: 'Product not found' });
    }

    // Toggle status
    product.status = product.status === 'available' ? 'out of stock' : 'available';

    // Save changes
    await product.save();
    console.log("Product status updated:", product.status);

    res.json({ success: true, message: 'Product status updated', product });
  } catch (error) {
    console.error("Error updating product status:", error);
    res.status(500).json({ message: 'Error updating product status', error });
  }
});


// Order Schema (similar to previous example)
const orderSchema = new mongoose.Schema({
  orderId: { type: String, unique: true },
  userName: String,
  address: String,
  productName: String,
  productImage: String,
  price: Number,
  quantity: Number,
  status: {
    type: String,
    enum: ['Pending', 'Processing', 'Shipped', 'Delivered', 'Canceled'],
    default: 'Pending'
  },
  createdAt: { type: Date, default: Date.now }
});

const Order = mongoose.model('Order', orderSchema);

// GET Orders with Filtering
app.get('/api/orders', async (req, res) => {
  try {
    const { name, priceRange, size, color, quantity, category } = req.query;
    console.log('Filters:', { name, priceRange, size, color,  category });

    const filter = {};
    if (name) filter.userName = { $regex: name, $options: 'i' };
    if (priceRange) {
      const [min, max] = priceRange.split('-');
      filter.price = { $gte: min, $lte: max };
    }
    if (size) filter.size = size;
    if (color) filter.color = color;
    if (category) filter.category = category;

    console.log('Filter:', filter);  // Check filter values

    const orders = await Order.find(filter);
    res.json(orders);
  } catch (err) {
    console.error('Error fetching orders:', err);
    res.status(500).json({ message: err.message });
  }
});

// POST /api/orders - Create a new order with generated orderId
app.post('/api/orders', upload.single('image'), async (req, res) => {
  try {
    console.log("Received file:", req.file); // Debugging
    console.log("Received body:", req.body); // Debugging

    if (!req.file) {
      return res.status(400).json({ error: "Order image upload failed" });
    }

    const lastOrder = await Order.findOne().sort({ createdAt: -1 });
    let lastCount = 0;
    if (lastOrder && lastOrder.orderId) {
      const countStr = lastOrder.orderId.substring(6, 9);
      lastCount = parseInt(countStr, 10) || 0;
    }
    const newCount = lastCount + 1;
    const newCountStr = newCount.toString().padStart(3, '0');
    const now = new Date();
    const dateTimeStr = ${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')};
    const newOrderId = Anant${newCountStr}${dateTimeStr};  

    const imagePath = /uploads/Products/${req.file.originalname};
    const { userName, address, productName, price, size, quantity } = req.body;

    if (!userName || !address || !productName || !price || !size || !quantity) {
      return res.status(400).json({ error: "Missing required fields" });
    }
    const newOrder = new Order({
      orderId: newOrderId,
      userName,
      address,
      productName,
      productImage: imagePath,
      price,
      size,
      quantity
    });
    await newOrder.save();

    res.status(201).json(newOrder);
  } catch (err) {
    console.error("Error creating order:", err);
    res.status(500).json({ message: err.message });
  }
});

// Update Order Status
app.patch('/api/orders/:id/status', async (req, res) => {
  try {
    const { status } = req.body;

    // Validate that the status is one of the allowed values
    const allowedStatuses = ['Pending', 'Completed', 'Shipped', 'Canceled', 'Processing'];
    if (!allowedStatuses.includes(status)) {
      return res.status(400).json({ message: 'Invalid status' });
    }

    const order = await Order.findByIdAndUpdate(req.params.id, { status }, { new: true });

    if (!order) {
      return res.status(404).json({ message: 'Order not found' });
    }

    res.json(order);
  } catch (error) {
    console.error('Error updating order status:', error);
    res.status(500).json({ message: error.message });
  }
});

// Update Order Details
app.put('/api/orders/:id', async (req, res) => {
  try {
    const { address, discount, productImage } = req.body;

    // Validate the fields before updating
    const updateFields = {};
    if (address) updateFields.address = address;
    if (discount) updateFields.discount = discount;
    if (productImage) updateFields.productImage = productImage;

    const order = await Order.findByIdAndUpdate(req.params.id, updateFields, { new: true });

    if (!order) {
      return res.status(404).json({ message: 'Order not found' });
    }

    res.json(order);
  } catch (err) {
    console.error('Error updating order details:', err);
    res.status(500).json({ message: err.message });
  }
});

// Delete Order
app.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const deletedOrder = await Order.findByIdAndDelete(id);

    if (!deletedOrder) {
      return res.status(404).json({ message: 'Order not found' });
    }

    res.json({ message: 'Order deleted successfully' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// :white_check_mark: Start the Express + Socket.IO Server (Fix for 404 error)
server.listen(PORT, () => {
  console.log(:rocket: Server running on http://localhost:${PORT});
});

















//cashfree api 



//main api and final


// app.post("/users/:id/orders", async (req, res) => {
//   try {
//     const { id } = req.params;
//     let { customer_name, customer_email, customer_phone, amount, shippingMethod, deliveryAddress, orderDetails } = req.body;

//     if (!id || !customer_name || !customer_email || !customer_phone || !amount || !deliveryAddress) {
//       return res.status(400).json({ error: "Missing required fields" });
//     }

//     customer_phone = String(customer_phone);

//     // Fetch user & determine next orderId
//     const user = await User.findById(id);
//     let newOrderId = "ORD001";

//     if (user && user.orders.length > 0) {
//       const lastOrder = user.orders[user.orders.length - 1];
//       const match = lastOrder.orderId.match(/ORD(\d+)/);
//       if (match) {
//         newOrderId = `ORD${String(parseInt(match[1], 10) + 1).padStart(3, "0")}`;
//       }
//     }

//     // Generate a unique link ID
//     const linkId = `CF_${crypto.randomBytes(8).toString("hex")}`;
    
//     // Prepare Cashfree payment link request
//     const payload = {
//       order_id: newOrderId,
//       link_id: linkId,
//       customer_details: { customer_name, customer_email, customer_phone },
//       link_amount: amount,
//       link_currency: "INR",
//       link_purpose: "E-commerce Purchase",
//       link_notify: { send_email: true, send_sms: true },
//       link_auto_reminders: true,
//       link_expiry_time: new Date(Date.now() + 3600 * 1000).toISOString(),
//       link_meta: {
//         return_url: `http://127.0.0.1:5501/Frontend/redirect.html?orderId=${newOrderId}&linkId=${linkId}&userId=${id}`
//       },
//     };

//     // Call Cashfree API to generate payment link
//     const response = await axios.post("https://sandbox.cashfree.com/pg/links", payload, {
//       headers: {
//         "x-api-version": "2022-09-01",
//         "x-client-id": APP_ID,
//         "x-client-secret": SECRET_KEY,
//       },
//     });

//     if (!response.data || !response.data.link_url) {
//       return res.status(500).json({ error: "Failed to generate payment link" });
//     }

//     // Store order with pending payment status
//     const newOrder = {
//       orderId: newOrderId,
//       linkId,
//       orderDetails,
//       price: amount,
//       shippingMethod: shippingMethod || "standard",
//       deliveryAddress: {
//         fullName: deliveryAddress.fullName,
//         phone: deliveryAddress.phone,
//         email: deliveryAddress.email,
//         street: deliveryAddress.street,
//         city: deliveryAddress.city,
//         postalCode: deliveryAddress.postalCode,
//         state: deliveryAddress.state,
//         country: deliveryAddress.country,
//       },
//       paymentDetails: { status: "pending", transactionId: "", paid: false },
//       status: "pending",
//       createdAt: new Date(),
//     };

//     const updatedUser = await User.findByIdAndUpdate(
//       id,
//       { $push: { orders: newOrder } },
//       { new: true }
//     );

//     if (!updatedUser) {
//       return res.status(404).json({ error: "User not found" });
//     }

//     res.json({
//       success: true,
//       userId: id,
//       orderId: newOrderId,
//       linkId,
//       linkUrl: response.data.link_url,
//       message: "Order created successfully, waiting for payment"
//     });

//   } catch (error) {
//     console.error("Error:", error.response?.data || error.message);
//     res.status(500).json({ error: "Error processing order", details: error.message });
//   }
// });



// app.post("/create-payment-link", async (req, res) => {
//   try {
//     let {
//       userId,
//       customer_name,
//       customer_email,
//       customer_phone,
//       amount,
//       shippingMethod,
//       deliveryAddress // Added delivery address
//     } = req.body;

//     if (!userId || !customer_name || !customer_email || !customer_phone || !amount || !deliveryAddress) {
//       return res.status(400).json({ error: "Missing required fields" });
//     }

//     customer_phone = String(customer_phone);

//     // Fetch the user's last order to determine the next orderId
//     const user = await User.findById(userId);
//     let newOrderId = "ORD001";

//     if (user && user.orders.length > 0) {
//       // Extract the last orderId and increment it
//       const lastOrder = user.orders[user.orders.length - 1];
//       const lastOrderId = lastOrder.orderId;

//       const match = lastOrderId.match(/ORD(\d+)/);
//       if (match) {
//         const orderNumber = parseInt(match[1], 10) + 1;
//         newOrderId = `ORD${String(orderNumber).padStart(3, "0")}`;
//       }
//     }

//     const linkId = `CF_${crypto.randomBytes(8).toString("hex")}`;
//     const payload = {
//       order_id: newOrderId,
//       link_id: linkId,
//       customer_details: { customer_name, customer_email, customer_phone },
//       link_amount: amount,
//       link_currency: "INR",
//       link_purpose: "E-commerce Purchase",
//       link_notify: { send_email: true, send_sms: true },
//       link_auto_reminders: true,
//       link_expiry_time: new Date(Date.now() + 3600 * 1000).toISOString(),
//       link_meta: {
//         return_url: `http://127.0.0.1:5501/Frontend/redirect.html?orderId=${newOrderId}&linkId=${linkId}&userId=${userId}`
//         // return_url: `https://indraq.tech/redirect.html?orderId=${newOrderId}&linkId=${linkId}&userId=${userId}`

//       },
//     };

//     const response = await axios.post("https://sandbox.cashfree.com/pg/links", payload, {
//       headers: {
//         "x-api-version": "2022-09-01",
//         "x-client-id": APP_ID,
//         "x-client-secret": SECRET_KEY,
//       },
//     });

//     // Save Order to MongoDB with delivery address
//     const newOrder = {
//       orderId: newOrderId,
//       linkId,
//       orderDetails: [],
//       price: amount,
//       shippingMethod: shippingMethod || "standard",
//       deliveryAddress: {
//         fullName: deliveryAddress.fullName,
//         phone: deliveryAddress.phone,
//         email: deliveryAddress.email,
//         street: deliveryAddress.street,
//         city: deliveryAddress.city,
//         postalCode: deliveryAddress.postalCode,
//         state: deliveryAddress.state,
//         country: deliveryAddress.country,
//       },
//       paymentDetails: { status: "pending" },
//       status: "pending",
//       createdAt: new Date(),
//     };

//     const updatedUser = await User.findByIdAndUpdate(
//       userId,
//       { $push: { orders: newOrder } },
//       { new: true }
//     );

//     if (!updatedUser) {
//       return res.status(404).json({ error: "User not found" });
//     }

//     res.json({ success: true, userId, orderId: newOrderId, linkId, linkUrl: response.data.link_url });

//   } catch (error) {
//     console.error("Cashfree Error:", error.response?.data || error.message);
//     res.status(500).json({ error: "Failed to create payment link" });
//   }
// });



// app.post("/users/:id/orders", async (req, res) => {
//   try {
//     const { id } = req.params;
//     const newOrder = req.body;

//     // ‚ùå Remove `_id` if it exists (MongoDB will generate it automatically)
//     if (newOrder._id) delete newOrder._id;

//     console.log("Received User ID:", id);
//     console.log("Processed Order:", JSON.stringify(newOrder, null, 2));

//     // Ensure delivery address is present
//     if (!newOrder.deliveryAddress) {
//       return res.status(400).json({
//         success: false,
//         message: "Missing delivery address information"
//       });
//     }

//     const updatedUser = await User.findByIdAndUpdate(
//       id,
//       { $push: { orders: newOrder } },
//       { new: true }
//     );

//     if (!updatedUser) {
//       return res.status(404).json({ success: false, message: "User not found" });
//     }

//     console.log("Order saved successfully for user:", id);
//     res.status(200).json({ success: true, message: "Order saved", order: newOrder });
//   } catch (error) {
//     console.error("Error saving order:", error);
//     res.status(500).json({ success: false, message: "Error saving order", error: error.message });
//   }
// });






































<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name>Profile Page</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="./index.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@8/swiper-bundle.min.css">
    <link rel="stylesheet" href="profile.css">
    <script src="config.js"></script>

    <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
</head>

<body>
    <div id="nav-placeholder">

    </div>

    <script>
        $(function () {
            $("#nav-placeholder").load("nav.html", function () {
                updateCartCounter(); // Ensure counter updates after loading nav
            });
        });
    </script>

    <div class="container">
        <div class="section-container" id="mainSections">
            <div class="section-card" onclick="showDetails('profile')">
                <div class="section-icon profile-icon">üë§</div>
                <div class="section-title">My Profile</div>
                <div class="section-subtitle">Edit Your Profile</div>
            </div>
            <div class="section-card" onclick="showDetails('orders')">
                <div class="section-icon orders-icon">üì¶</div>
                <div class="section-title">My Orders</div>
                <div class="section-subtitle">Check Your Orders</div>
            </div>
            <div class="section-card" onclick="showDetails('addresses')">
                <div class="section-icon address-icon">üìç</div>
                <div class="section-title">My Addresses</div>
                <div class="section-subtitle">Edit Addresses for orders</div>
            </div>
        </div>
    </div>

    <!-- Profile Section -->
    <div class="detail-container" id="profileDetails">
        <h2>Personal Details</h2>

        <!-- Profile Image Preview -->
        <img id="profileImagePreview" src="" alt="Profile Image"
            style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover;">

        <!-- File Upload Input -->
        <input type="file" id="profileImageInput" accept="image/*" style="display: none;">
        <button class="edit-btn" onclick="document.getElementById('profileImageInput').click()">Choose Image</button>

        <!-- Upload Button -->
        <button id="upload-btn" class="save-btn" onclick="uploadProfileImage()" style="display: none;">Upload</button>

        <p><strong>First Name:</strong> <input class="form-input" id="firstName" readonly></p>
        <p><strong>Last Name:</strong> <input class="form-input" id="lastName" readonly></p>
        <p><strong>Email:</strong> <input class="form-input" id="email" readonly></p>
        <p><strong>Phone:</strong> <input class="form-input" id="phone" readonly></p>

        <button class="edit-btn" id="editProfileBtn" onclick="editProfile()">Edit Profile</button>
        <button class="save-btn" id="saveProfileBtn" onclick="saveProfile()" style="display: none;">Save
            Profile</button>

        <div class="back-btn" onclick="goBack()">Back</div>
    </div>

    <!-- Address Section -->
    <div class="detail-container" id="addressesDetails">
        <h2>Saved Addresses</h2>
        <div id="addressesList">Loading...</div>
        <button class="edit-btn" onclick="openAddressPopup()">Add New Address</button>
        <!-- <button class="save-btn" onclick="fetchUserAddresses()">Refresh Addresses</button> -->
        <div class="back-btn" onclick="goBack()">Back</div>
    </div>

    <!-- Add Address Popup -->
    <div id="addressPopup" class="popup-overlay" style="display: none;">
        <div class="popup-content">
            <h2>Add New Address</h2>
            <input class="form-input" id="newStreet" placeholder="Street">
            <input class="form-input" id="newCity" placeholder="City">
            <input class="form-input" id="newPostalCode" placeholder="Postal Code">
            <input class="form-input" id="newState" placeholder="State">
            <input class="form-input" id="newCountry" placeholder="Country">
            <button type="button" class="btn btn-primary" onclick="saveNewAddress()">Save Address</button>
            <button class="back-btn" onclick="closeAddressPopup()">Cancel</button>
        </div>
    </div>

    <!-- Edit Address Popup -->
    <div id="editAddressPopup" class="popup-overlay" style="display: none;">
        <div class="popup-content">
            <h2>Edit Address</h2>
            <input type="hidden" id="editAddressId">
            <input class="form-input" id="editStreet" placeholder="Street">
            <input class="form-input" id="editCity" placeholder="City">
            <input class="form-input" id="editPostalCode" placeholder="Postal Code">
            <input class="form-input" id="editState" placeholder="State">
            <input class="form-input" id="editCountry" placeholder="Country">
            <button class="btn btn-primary" onclick="updateAddress()">Update Address</button>
            <button class="back-btn" onclick="closeEditAddressPopup()">Cancel</button>
        </div>
    </div>

    <!-- Orders Section -->
    <div class="detail-container" id="ordersDetails">
        <h2>My Orders</h2>
        <div id="ordersList" class="orders-container">
            <!-- Orders will be dynamically populated here -->
        </div>
        <div class="back-btn" onclick="goBack()">Back</div>
    </div>

    <!-- Order Details Section -->
    <div class="detail-container" id="orderDetails" style="display: none;">
        <div id="orderDetailsHeader">
            <!-- Order header details will be dynamically populated -->
        </div>
        <div id="orderInfo" class="order-items-container">
            <!-- Order items will be dynamically populated -->
        </div>
        <div class="back-btn" onclick="showOrders()">Back to Orders</div>
    </div>

    <script>
        document.getElementById("profileImageInput").addEventListener("change", function (event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    document.getElementById("profileImagePreview").src = e.target.result;
                    document.getElementById("upload-btn").style.display = "inline-block"; // Show upload button
                };
                reader.readAsDataURL(file);
            }
        });

        async function uploadProfileImage() {
            const fileInput = document.getElementById("profileImageInput");
            const file = fileInput.files[0];

            if (!file) {
                alert("Please select an image first.");
                return;
            }

            const _id = localStorage.getItem("_id");
            console.log("User ID from localStorage:", _id);

            const formData = new FormData();
            formData.append("profileImage", file);

            try {
                const response = await fetch(`${CONFIG.API_URL}/users/${_id}/upload`, {
                    method: "POST",
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    alert("Profile image updated!");
                    document.getElementById("profileImagePreview").src = `${CONFIG.API_URL}${data.imageUrl}`;
                    document.getElementById("upload-btn").style.display = "none";

                    // Update user profile in localStorage with new image URL
                    const storedUserProfile = localStorage.getItem("userProfile");
                    if (storedUserProfile) {
                        const userProfile = JSON.parse(storedUserProfile);
                        userProfile.profileImage = `${CONFIG.API_URL}${data.imageUrl}`;
                        localStorage.setItem("userProfile", JSON.stringify(userProfile));
                    }

                    else {
                        // If no stored profile, fetch updated user data
                        fetchUserData();
                    }

                    // Ensure the Personal Details section remains visible
                    showDetails('profile');
                } else {
                    alert("Image upload failed!");
                }
            } catch (error) {
                console.error("Error uploading image:", error);
                alert("Error uploading image!");
            }
        }

        function showDetails(section) {
            document.getElementById("mainSections").style.display = "none";
            document.getElementById("profileDetails").style.display = section === "profile" ? "block" : "none";
            document.getElementById("addressesDetails").style.display = section === "addresses" ? "block" : "none";
            document.getElementById("ordersDetails").style.display = section === "orders" ? "block" : "none";

            if (section === "addresses") {
                fetchUserAddresses();
            } else if (section === "orders") {
                fetchOrders();
            }
        }

        function goBack() {
            document.getElementById("mainSections").style.display = "flex";
            document.getElementById("profileDetails").style.display = "none";
            document.getElementById("addressesDetails").style.display = "none";
            document.getElementById("ordersDetails").style.display = "none";
        }

        function getUserEmail() {
            return localStorage.getItem("userEmail");  // Retrieve the email from localStorage
        }

        // Fetch user data based on email
        function fetchUserData() {
            try {
                const storedUserProfile = localStorage.getItem("userProfile");

                if (storedUserProfile) {
                    const user = JSON.parse(storedUserProfile);
                    if (user._id) localStorage.setItem("_id", user._id); // Store _id separately
                    populateUserDetails(user);
                    return;
                }

                const userEmail = getUserEmail();
                if (!userEmail) throw new Error("No email found");

                fetch(`${CONFIG.API_URL}/users/email/${userEmail}`)
                    .then(response => {
                        if (!response.ok) throw new Error("User not found");
                        return response.json();
                    })
                    .then(user => {
                        localStorage.setItem("_id", user._id); // Store _id separately
                        populateUserDetails(user);
                    })
                    .catch(error => console.error("Error fetching user details:", error));
            } catch (error) {
                console.error("Error fetching user details:", error);
            }
        }

        function populateUserDetails(user) {
            document.getElementById("firstName").value = user.firstName;
            document.getElementById("lastName").value = user.lastName;
            document.getElementById("email").value = user.email;
            document.getElementById("phone").value = user.phone;

            if (user.profileImage) {
                document.getElementById("profileImagePreview").src = user.profileImage;
                localStorage.setItem("userProfile", JSON.stringify(user)); // Update localStorage
            }
        }

        const storedUserProfile = localStorage.getItem("userProfile");

        if (storedUserProfile) {
            const user = JSON.parse(storedUserProfile);
            if (user.profileImage) {
                document.getElementById("profileImagePreview").src = user.profileImage;
            }
        }

        // Edit Profile Function - Make fields editable
        function editProfile() {
            // Make input fields editable
            document.getElementById("firstName").readOnly = false;
            document.getElementById("lastName").readOnly = false;
            document.getElementById("phone").readOnly = false;

            // Email should remain readonly as it's often used as an identifier
            // document.getElementById("email").readOnly = false;

            // Add active class to editable fields
            document.getElementById("firstName").classList.add("editable");
            document.getElementById("lastName").classList.add("editable");
            document.getElementById("phone").classList.add("editable");

            // Show save button and hide edit button
            document.getElementById("saveProfileBtn").style.display = "inline-block";
            document.getElementById("editProfileBtn").style.display = "none";
        }

        // Save Profile Function - Send updated profile to backend
        async function saveProfile() {
            const _id = localStorage.getItem("_id");
            if (!_id) {
                alert("User ID not found! Please log in again.");
                return;
            }

            // Gather updated profile data
            const updatedProfile = {
                firstName: document.getElementById("firstName").value,
                lastName: document.getElementById("lastName").value,
                phone: document.getElementById("phone").value
                // Email is typically not changed this way
            };

            try {
                const response = await fetch(`${CONFIG.API_URL}/users/${_id}/update`, {
                    method: "PUT",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(updatedProfile)
                });

                if (response.ok) {
                    const data = await response.json();
                    alert("Profile updated successfully!");

                    // Update stored user profile
                    const storedUserProfile = localStorage.getItem("userProfile");
                    if (storedUserProfile) {
                        const userProfile = JSON.parse(storedUserProfile);
                        userProfile.firstName = updatedProfile.firstName;
                        userProfile.lastName = updatedProfile.lastName;
                        userProfile.phone = updatedProfile.phone;
                        localStorage.setItem("userProfile", JSON.stringify(userProfile));
                    }

                    // Reset fields to readonly
                    document.getElementById("firstName").readOnly = true;
                    document.getElementById("lastName").readOnly = true;
                    document.getElementById("phone").readOnly = true;

                    // Remove editable class
                    document.getElementById("firstName").classList.remove("editable");
                    document.getElementById("lastName").classList.remove("editable");
                    document.getElementById("phone").classList.remove("editable");

                    // Show edit button and hide save button
                    document.getElementById("saveProfileBtn").style.display = "none";
                    document.getElementById("editProfileBtn").style.display = "inline-block";
                } else {
                    alert("Failed to update profile!");
                }
            } catch (error) {
                console.error("Error updating profile:", error);
                alert("Error updating profile!");
            }
        }



        // Fetch and display user orders
        async function fetchOrders() {
    const _id = localStorage.getItem("_id");
    if (!_id) {
        showErrorMessage("User ID not found! Please log in again.");
        return;
    }

    try {
        const response = await fetch(`${CONFIG.API_URL}/users/${_id}/orders`);
        if (!response.ok) {
            showErrorMessage("Failed to fetch orders");
            return;
        }

        const data = await response.json();
        const ordersContainer = document.getElementById("ordersList");
        ordersContainer.innerHTML = "";

        if (!data.orders || data.orders.length === 0) {
            ordersContainer.innerHTML = "<p>No orders found.</p>";
            return;
        }

        // Store orders in a global variable for easy access
        window.userOrders = data.orders;

        data.orders.forEach(order => {
            // Ensure we have order details and required properties
            if (!order.orderDetails || order.orderDetails.length === 0) {
                return;
            }

            // Calculate subtotal
            const subtotal = order.totalAmount || 
                order.orderDetails.reduce((total, item) => 
                    total + ((item.price || 0) * (item.quantity || 1)), 
                0);

            // Calculate GST (18%)
            const gstRate = 0.18;
            const gstAmount = subtotal * gstRate;
            
            // Use the shippingPrice from the order
            const shippingPrice = order.shippingPrice || 0;
            
            // Calculate grand total (subtotal + GST + shipping)
            const grandTotal = subtotal + gstAmount + shippingPrice;

            const orderDate = order.date ? new Date(order.date) : new Date();
            const deliveryDate = new Date(orderDate);
            deliveryDate.setDate(orderDate.getDate() + 5);

            const orderWrapper = document.createElement("div");
            orderWrapper.className = "order-wrapper";
            orderWrapper.setAttribute("data-order-id", order.orderId || 'N/A');
            orderWrapper.setAttribute("data-order-index", data.orders.indexOf(order));

            orderWrapper.innerHTML = `
                <div class="order-header">
                    <div class="order-date">
                        <p>ORDER PLACED</p>
                        <p>${orderDate.toLocaleDateString('en-US', { day: 'numeric', month: 'short', year: 'numeric' })}</p>
                    </div>
                    <div class="order-total">
                        <p>TOTAL</p>
                        <p>‚Çπ${grandTotal.toLocaleString()}</p>
                    </div>
                    <div class="order-ship-to">
                        <p>SHIP TO</p>
                        <p>${order.deliveryAddress?.fullName || 'N/A'}</p>
                    </div>
                    <div class="order-number">
                        <p>ORDER # ${order.orderId || 'N/A'}</p>
                        <a href="#" class="view-details">View order details</a>
                    </div>
                </div>

                ${order.orderDetails.map(item => `
                    <div class="order-item">
                        <div class="order-item-status">
                            <p>${order.orderStatus || 'Delivered'}</p>
                            <p>Package was handed to resident</p>
                        </div>
                        <div class="order-item-details">
                            <img src="${item.image || ''}" alt="${item.name || 'Product'}">
                            <div class="item-info">
                                <h4>${item.name || 'Unnamed Product'}</h4>
                                <div class="item-actions">
                                    <button class="btn-secondary">View your item</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('')}
            `;

            ordersContainer.appendChild(orderWrapper);
        });

        // Add event delegation for order details
        ordersContainer.addEventListener('click', function (event) {
            const orderWrapper = event.target.closest('.order-wrapper');
            if (orderWrapper) {
                const orderIndex = orderWrapper.getAttribute('data-order-index');
                if (orderIndex !== null) {
                    showOrderDetails(window.userOrders[orderIndex]);
                }
            }
        });
    } catch (error) {
        console.error("Error fetching orders:", error);
        showErrorMessage(`Error fetching orders: ${error.message}`);
    }
}

function showOrderDetails(order) {
    try {
        const orderDetailsContainer = document.getElementById("orderDetails");
        const ordersListContainer = document.getElementById("ordersDetails");

        if (!orderDetailsContainer || !ordersListContainer) {
            console.error("Required DOM elements not found!");
            return;
        }

        // Calculate subtotal
        const subtotal = order.totalAmount || 
            order.orderDetails.reduce((total, item) => 
                total + ((item.price || 0) * (item.quantity || 1)), 
            0);

        // Calculate GST (18%)
        const gstRate = 0.18;
        const gstAmount = subtotal * gstRate;

        // Use the shippingPrice from the order
        const shippingPrice = order.shippingPrice || 0;

        // Calculate grand total (subtotal + GST + shipping)
        const grandTotal = subtotal + gstAmount + shippingPrice;

        const orderDate = new Date(order.date || Date.now());
        const deliveryDate = new Date(orderDate);
        deliveryDate.setDate(orderDate.getDate() + 5); // Adjust as needed

        orderDetailsContainer.innerHTML = `
            <div class="order-details-header">
                <div class="order-details-summary">
                    <p>Order placed on ${orderDate.toLocaleDateString('en-US', { day: 'numeric', month: 'long', year: 'numeric' })}</p>
                    <p>Order # ${order.orderId || 'N/A'}</p>
                </div>
                <div class="order-details-actions">
                    <button class="btn-secondary" onclick="showOrders()">Back to Orders</button>
                    <button class="btn-secondary">Invoice</button>
                </div>
            </div>

            <div class="order-shipping-info">
                <div class="shipping-details">
                    <h3>Shipping Details</h3>
                    <p>${order.deliveryAddress?.fullName || 'N/A'}</p>
                    <p>${order.deliveryAddress?.phone || 'N/A'}</p>
                    <p>${order.deliveryAddress?.email || 'N/A'}</p>
                    <p>${order.deliveryAddress?.street || 'N/A'}</p>
                    <p>${order.deliveryAddress?.city || 'N/A'}, ${order.deliveryAddress?.state || 'N/A'} ${order.deliveryAddress?.postalCode || ''}</p>
                    <p>${order.deliveryAddress?.country || 'N/A'}</p>
                </div>
            </div>

            ${order.orderDetails.map(item => `
                <div class="detailed-order-item">
                  
                    <div class="item-details">
                        <img src="${item.image || ''}" alt="${item.name || 'Product'}">
                        <div class="item-info">
                            <h3>${item.name || 'Unnamed Product'}</h3>
                            <p>Sold by: ${item.seller || 'N/A'}</p>
                            <p>Price: ‚Çπ${(item.price || 0).toLocaleString()}</p>
                            <p>Quantity: ${item.quantity || 1}</p>
                            <div class="item-actions">
                                <button class="btn-secondary">Return/Replacement</button>
                                <button class="btn-secondary">Write a product review</button>
                                <button class="btn-primary">Buy it again</button>
                            </div>
                        </div>
                    </div>
                </div>
            `).join('')}

            <div class="order-summary">
                <h3>Order Summary</h3>
                <div class="summary-details">
                    <p>Item(s) Subtotal: ‚Çπ${subtotal.toLocaleString()}</p>
                    <p>GST (18%): ‚Çπ${gstAmount.toLocaleString()}</p>
                    <p>Shipping: ‚Çπ${shippingPrice.toLocaleString()}</p>
                    <p><strong>Grand Total: ‚Çπ${grandTotal.toLocaleString()}</strong></p>
                </div>
            </div>
        `;

        // Toggle visibility
        ordersListContainer.style.display = "none";
        orderDetailsContainer.style.display = "block";

    } catch (error) {
        console.error("Error in showOrderDetails:", error);
        showErrorMessage("Failed to load order details");
    }
}
        // Return to orders list
        function showOrders() {
            const orderDetailsContainer = document.getElementById("orderDetails");
            const ordersListContainer = document.getElementById("ordersDetails");

            if (orderDetailsContainer && ordersListContainer) {
                orderDetailsContainer.style.display = "none";
                ordersListContainer.style.display = "block";
            }
        }

        // Helper function to show error messages
        function showErrorMessage(message) {
            const errorContainer = document.getElementById("errorContainer");
            if (errorContainer) {
                errorContainer.innerHTML = `<p class="error-message">${message}</p>`;
                errorContainer.style.display = "block";
            } else {
                alert(message);
            }
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', () => {
            fetchOrders();
        });